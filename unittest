#!/bin/sh
#
# unittest - unit tests framework for shell scripts.
#
# SPDX-FileCopyrightText: 2014 Maciej Å»ok <https://github.com/macie/unittest.sh>
# SPDX-License-Identifier: MIT
set -u

readonly UNITTEST_VERSION='local-dev'
UNITTEST_CURRENT='unknown_testfile:unknown_testfunc'
UNITTEST_COLOR='auto'  # 'auto' | 'on' | 'off'


#
#   MESSAGES
#

	# Write test status message to stdout
unittest__print_result() (
	readonly testcase="${1:-unknown}"
	readonly status="${2:-????}"

	if [ "$UNITTEST_COLOR" = 'on' ] || { [ -t 1 ] && [ "$UNITTEST_COLOR" = 'auto' ]; }; then
		readonly color_normal='\033[0m'
		case $status in
			PASS)
				readonly color_testcase='\033[0m'  # default
				readonly color_status='\033[32m'  # green
				;;
			FAIL)
				readonly color_testcase='\033[31m'  # red
				readonly color_status='\033[97;41m'  # white on red
				;;
			SKIP)
				readonly color_testcase='\033[37m'  # gray
				readonly color_status='\033[37m'  # gray
				;;
			*)
				readonly color_testcase='\033[90m'  # dark gray
				readonly color_status='\033[97;100m'  # white on dark gray
				;;
		esac
	fi

	printf "${color_testcase-}%s\t${color_status-}%s${color_normal-}\n" "$testcase" "$status"

	return 0
)

unittest__print_debug() (
	readonly header="${1:-'UNKNOWN ERROR'}"
	shift 1  # $@ - paragraphs

	if [ "$UNITTEST_COLOR" = 'on' ] || { [ -t 2 ] && [ "$UNITTEST_COLOR" = 'auto' ]; }; then
		readonly color_normal='\033[0m'
		readonly color_header='\033[34m'  # blue
		readonly color_quote='\033[37m'  # gray
	fi

	printf "\n${color_header-}-- %s${color_normal-}\n\n" "$header" >&2

	for paragraph in "$@"; do
		# shellcheck disable=SC2059 # '%b' is not portable yet
		case ${paragraph} in
			' '*) printf "${color_quote-}" >&2 ;;
			*)  ;;
		esac
		printf "%s${color_normal-}\n\n" "${paragraph}" >&2
	done

	return 0
)

#
#   ASSERTIONS
#

# shellcheck disable=SC2317
test() (
	# same arguments as command test(1)
	error_msg=$(/bin/test "$@" 2>&1)
	case $? in
		0)  ;;
		1)
			unittest__print_debug "FAILED TEST [${UNITTEST_CURRENT}]" \
				'I expected:' \
				"    test$(printf " '%s'" "$@")" \
				'to be true, but the result was false.'
			return 1
			;;
		*)
			unittest__print_debug "INVALID ASSERTION [${UNITTEST_CURRENT}]" \
				'I tried to check' \
				"    test$(printf " '%s'" "$@")" \
				'but I got error with message:' \
				"    ${error_msg}" \
				'Did you use proper operator?' \
				"Hint: Some operators requires specific type of values. Read 'man test' to learn more."
			return 1
			;;
	esac

	return 0
)


#
#   FUNCTIONS
#

##
# Find files with tests (test_*.sh).
# SYNOPSIS:
#     unittest__test_files [directory...]
# OPERANDS:
#     directory - A pathname of directory to search in. If no directory is
#         given, it will look for 'tests' directory inside current one. If
#         a directory is '-', it will use stdin.
# STDIN:
#     (optional) List of directories to search in. Used when call with '-' argument.
# STDOUT:
#     List of 'test_*.sh' file paths.
# STDERR:
#     (optional) Debug/error message.
# EXIT STATUS:
#     0 - Successfully traversed all directories.
#    >0 - An error occurred.
# EXAMPLES:
#     unittest__test_files ./unit_tests ./integration_tests
#     ls ../ | unittest__test_files -
# CAVEATS:
#     Calling it inside pipeline without '-' will disregards standard input and
#     use defaults instead.
unittest__test_files() (
	{
		if [ "${1-}" = '-' ]; then
			cat -
		else
			printf '%s\n' "$@"
		fi
	 } |
	while read -r testdir; do
		if ! find "${testdir:-./}" -path "*${testdir:-tests/}*" -name 'test_*.sh' 2>/dev/null; then
			 unittest__print_debug 'TESTS NOT FOUND' \
				"I was looking for 'test_*.sh' files inside '${testdir:-tests/}' directory using:" \
				"    $ find \"${testdir:-./}\" -path \"*${testdir:-tests/}*\" -name 'test_*.sh' -print" \
				 'but instead of files I got an error with message:' \
				"    $(find "${testdir:-./}" -path "*${testdir:-tests/}*" -name 'test_*.sh' -print 2>&1)"
			 return 1
		 fi
	 done

	 return $?
)

##
# Run tests from given files.
# STDIN: List of files.
# STDOUT: Test name with status.
# STDERR: (optional) Debug/error message.
# EXIT STATUS:
#     0 - All tests passed.
#    >0 - Some tests failed.
##
unittest__run() {
	# prefix: utt8r_

	UNITTEST_STATUS=0
	while read -r utt8r_testfile; do
		(
			utt8r_beforeAll=$(sed -n 's/^[ \t]*\(beforeAll\)[ \t]*(.*/\1/p' "${utt8r_testfile}")
			utt8r_afterAll=$(sed -n 's/^[ \t]*\(afterAll\)[ \t]*(.*/\1/p' "${utt8r_testfile}")
			utt8r_beforeEach=$(sed -n -e 's/^[ \t]*\(beforeEach\)[ \t]*(.*/\1/p' -e 's/^[ \t]*\(setUp\)[ \t]*(.*/\1/p' "${utt8r_testfile}")
			utt8r_afterEach=$(sed -n -e 's/^[ \t]*\(afterEach\)[ \t]*(.*/\1/p' -e 's/^[ \t]*\(tearDown\)[ \t]*(.*/\1/p' "${utt8r_testfile}")
			utt8r_tests=$(awk '/^[^{]*}/ { nesting-- } /^[ \t]*x{0,1}test_[^(=]*\(.*/ { if (nesting == 0) { print $1 } } /{[^}]*$/ { nesting++ }' "${utt8r_testfile}" | tr -d '(){}')

			# shellcheck source=/dev/null
			. "${utt8r_testfile}"
			${utt8r_beforeAll}
			for _current_testcase in ${utt8r_tests}; do
				UNITTEST_CURRENT="${utt8r_testfile#./}:${_current_testcase}"

				case ${_current_testcase} in
					x*)
						unittest__print_result "${UNITTEST_CURRENT}" 'SKIP'
						;;
					*)
						${utt8r_beforeEach}
						# test result is status of last command in test
						if ${_current_testcase}; then
							unittest__print_result "${UNITTEST_CURRENT}" 'PASS'
						else
							# last command in test failed
							UNITTEST_STATUS=1
							unittest__print_result "${UNITTEST_CURRENT}" 'FAIL'
						fi
						${utt8r_afterEach}
						;;
				esac
			done
			${utt8r_afterAll}
			unset -v UNITTEST_CURRENT
			exit ${UNITTEST_STATUS}
		)
		UNITTEST_STATUS=$?
	done
	return ${UNITTEST_STATUS}
}


#
#   MAIN ROUTINE
#

{
	# Color output by default: on supported terminals when NO_COLOR is not set.
	# Supported terminals are recognized based on TERM variable. When TERM is
	# not set (for example inside CI environment) we assume that terminal is dumb.
	# NO_COLOR has precedence over CLICOLOR_FORCE. See: https://bixense.com/clicolors/
	if [ -n "${NO_COLOR:-}" ]; then
		UNITTEST_COLOR='off'
	elif [ -n "${CLICOLOR_FORCE:-}" ]; then
		UNITTEST_COLOR='on'
	elif [ "$(TERM=${TERM:-dumb} tput colors)" -lt 8 ]; then
		UNITTEST_COLOR='off'
	fi

	case $# in
		0)  # discovery mode
			unittest__test_files | unittest__run
			exit $?
			;;
		1)
			case $1 in
				-h|--help)
					cat >&2 <<-'EOF'
						unittest - unit tests framework for shell scripts.

						Usage:
						  unittest [options] [test_directory | test_file]

						Options:
						  -h, --help           Show this help and exit.
						  -v, --version        Show version number and exit.

						Without any arguments it will run all tests from 'tests' directory.
						EOF
					exit 0
					;;

				-v|--version)
					printf 'unittest %s\n' "$UNITTEST_VERSION" >&2
					exit 0
					;;
				*)  # specified directory/file
					if [ -d "$1" ]; then
						unittest__test_files "$1" | unittest__run
						exit $?
					elif [ -f "$1" ]; then
						printf '%s\n' "$1" | unittest__run
						exit $?
					fi
					;;
			esac
	esac

	unittest__print_debug 'INVALID USAGE' \
		"I cannot understand '$*' option. Did you want to use option or did you misspell file/directory?" \
		'Hint: Find valid usage with:' \
		'    $ unittest -h'
	exit 64  # EX_USAGE
}
